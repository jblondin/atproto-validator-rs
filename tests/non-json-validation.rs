/*
An example demonstrating validation of an arbitrary object (instead of the `serde_json::Value`-based
validation implemented as part of the "json" feature).
 */

use atproto_validator::{Document, DocumentType, Error, ObjectDef, Validate, ValidateObject};
use atrium_api::types::string::Datetime;

pub mod lexicons;
use lexicons::record_document_json;

// This definition is taken from the file generated by esquema-codegen (forked from atrium-codegen).
// A `$type` field has been added to match objects normally retrieved from the stream
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RecordData {
    #[serde(rename = "$type")]
    pub r#type: String,
    pub created_at: Datetime,
    pub status: String,
}

impl<'a> Validate<DocumentType<'a>> for RecordData {
    fn validate(&self, doc_type: &DocumentType<'a>, errs: &mut Vec<Error>) {
        if self.r#type != doc_type.as_str() {
            errs.push(Error::TypeMismatch {
                expected: doc_type.as_str().to_owned(),
                actual: self.r#type.clone(),
            });
        }
    }
}

impl Validate<ObjectDef> for RecordData {
    fn validate(&self, def: &ObjectDef, errs: &mut Vec<Error>) {
        if let Some(string_def) = def.get_string_prop("createdAt", errs) {
            self.created_at.as_str().validate(string_def, errs);
        }
        if let Some(string_def) = def.get_string_prop("status", errs) {
            self.status.as_str().validate(string_def, errs);
        }
    }
}

#[test]
pub fn validate_non_json_object() {
    let doc =
        match serde_json::from_value::<Document>(record_document_json("xyz.statusphere.status")) {
            Ok(doc) => doc,
            Err(e) => panic!("lexicon deserializtion failed: {e}"),
        };

    let object = RecordData {
        r#type: "xyz.statusphere.status".to_owned(),
        created_at: Datetime::now(),
        status: "ðŸ˜±".to_owned(),
    };
    let validation_results = object.validate_object(&doc);
    assert!(validation_results.is_ok());

    let object = RecordData {
        r#type: "xyz.statusphere.status".to_owned(),
        created_at: Datetime::now(),
        status: "ðŸ˜±ðŸ˜±".to_owned(),
    };
    let validation_results = object.validate_object(&doc);
    assert!(validation_results.is_err());
    let error = validation_results.unwrap_err().pop().unwrap();
    let Error::NumGraphemeshOutOfBounds(2, None, Some(1)) = error else {
        panic!("unexpected error {error}!");
    };
}
